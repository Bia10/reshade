in Device
	- track each created depth stencil buffer with its description
	
	
in Context
	- track each depth stencil bind change so the active depth stencil (or none!) is tracked. This inside the context. Also track each set
	  stencil buffer in a map with an int as value. This means also OMSetDepthStencilState!
	- on a draw call, if an active depth stencil is set in the context, add 1 to the number in the map for the stencil buffer. 
	- when FinishCommandList is called, the map with the pointers to the stencil buffers + counters is stored in the runtimes with the commandlist pointer!, and
	  they're cleared if state is cleared. (look into this, it looks like state is always cleared?). Drawcalls are also the indirect ones!
	- on ExecuteCommandList, the stencilbuffer pointers + counters is pulled from the runtimes for the commandlist pointer (why not static?) and merged into
	  the context's map so it looks like the commands are called on this context. 

On present:
	- the immediate context has all the numbers now. Just pull the stencil buffer pointers with the counters and from there, do:
		- per stencil buffer pointer pull the desc from the tracker which stored this info on creation of the buffers
		- if the desc contains a resolution not matching our own, ignore
		- if it matches, check the draw call count. If it's the highest, pick that one. 
	- the buffer with the highest draw call count is picked, create replacement as normal. 

When to remove commandlist pointers from tracker? Or buffers? It's unlikely a scene is rendered using commandlists which are re-used across frames, 
as the camera is moving and therefore the commands what to render changes. Unless what to render is computed with compute shaders but that's unlikely too
considering the fact the data it has to use (culling etc.) isn't on the card.